# 后台开发日志

## 21.09.29 ~ 21.10.03

这几天一直在研究SpringSecurity配合鉴权，以及使用vue-element-template搭建后台系统，无果。

转而开始使用sa-token鉴权，效果不错，算是刚刚起步吧

## 21.10.04

前后端交互就用token认证，把token塞进请求头header中 Authorization : tokenValue

#### 问题待解决

xyz.dg.dgpethome.config.SaTokenConfigure下角色认证有问题，怀疑是因为写了/admin/*导致，因为我的登录叫/admin/login导致后续也被识别到，出现了**在请求登录接口的时候就报token未认证异常 **,暂时注释掉，之后再弄好点。

```java
 SaRouter.match(Arrays.asList("/**"), Arrays.asList("/admin/login"), () -> StpUtil.checkLogin());
//SaRouter.match("/admin/**", () -> StpUtil.checkRoleOr("20", "21"));
```

#### 问题已解决

晚上一直在尝试用后台管理系统的GET请求方式给后端发 类似于下面这种对象数据，但发送的请求会变成userVo[userName]的形式在url上无法识别, 用Post请求在后台用@RequestBody倒是能实现，但违背了我想用GET请求的方式

```vue
params:{
    // 搜索框表单数据
	userVo: {
		userName: ''
	}, 
    currentPage: 1,
    pageSize: 10,
    totalNum: 0
}
```

无论是JSON.stringify()去转还是用qs.stringify()实现都无果 ， 搜索了网上案例都不能很好实现，遂放弃转而只传值，不搞非主流的传对象

#### 对象的分页数据包装

原先从数据库取数据总是包含了不必要的字段，故包装了一下需要的字段，但在用Mybatis-plus的分页的时候又不想搞的太复杂,只想实现简单的Ipage<SysUser> -> Ipage<SysUserVo>,查了下可以用hutool的core包下的BeanUtil来解决

```java
this.baseMapper.selectPage(userPage,queryWrapper)
.convert(item-> BeanUtil.copyProperties(item,SysUserVo.class))
```

### 21.10.07

将原先本来用mybatis-plus的分页查询改成了自己的，方便多表查询

```java
IPage<SysUserVo> userVoIPage = new Page<>();
userVoIPage.setPages(sysUserPageParam.getPageSize());
userVoIPage.setCurrent(sysUserPageParam.getCurrentPage());

List<SysUserVo> list = sysUserMapper.findUserList(sysUserPageParam);
System.out.println(list.toString());
userVoIPage.setRecords(list);
```

```sql
 <select id="findUserList" resultMap="BaseResultMap_Vo"  parameterType="xyz.dg.dgpethome.model.page.SysUserPageParam">
    SELECT
      <include refid="Base_Column_List_Vo" />
      FROM `sys_dict` d1
      join `sys_user` u on u.user_role_id = d1.dict_id
        <where>
            d1.dict_parent_id = #{sysUserPageParam.dictParentId}
            and
            u.user_name LIKE concat('%',#{sysUserPageParam.userName,jdbcType=VARCHAR},'%')
        </where>
    </select>
```

### 21.10.08

修复了使用limit分页前端错误显示的错误，以及使用了自定义的分页(查全部再在impl进行分页返回)

```java
List<SysUserVo> totalList = sysUserMapper.findUserList(sysUserPageParam);
        //开始
        Long front = (sysUserPageParam.getCurrentPage()-1)*sysUserPageParam.getPageSize();
        //结尾
        Long end = Math.min(sysUserPageParam.getCurrentPage()*sysUserPageParam.getPageSize(),totalList.size());
        List<SysUserVo> limitList = totalList.subList(front.intValue(),end.intValue());
        System.out.println(limitList.toString());
        userVoIPage.setRecords(limitList);
        userVoIPage.setTotal(totalList.size());
```

### 21.10.12

这几天在弄了有关于字典方面的接口和数据,主要是在弄前端的级联选择器，一开始想弄动态加载之类的，但还是以简便为主，后期有时间就可以弄，顺便改下这个递归查找

```java
/**
     * 递归查找字典
     * @param dictParentId
     * @param tree
     * @return
     */
    private List<CascaderSysDictVo> getTreeDataLoop(Integer dictParentId,List<CascaderSysDictVo> tree) {
        // 获取父字典下所有的字典数据
        List<SysDictVo> dictTree = this.findDictByParentId(dictParentId);
        // 判断子级是否还有子级
        if (dictTree == null || dictTree.size() < 1) {
            // 如果没有子级则返回空
            return null;
        }
//        Map<Integer, SysDictVo> map = new HashMap<>();
//        // 将所有的数据，以键值对的形式装入map中
//        for (SysDictVo productType : productTypes) {
//            map.put(productType.getDictId(), productType);
//        }
        List<CascaderSysDictVo> result = new ArrayList<>();
        for (SysDictVo dictVo : dictTree) {
                // 如果id是父级的话就放入tree中
                CascaderSysDictVo temp =  new CascaderSysDictVo();
                temp.setDictId(dictVo.getDictId());
                temp.setDictValue(dictVo.getDictValue());
                temp.setList(getTreeDataLoop(dictVo.getDictId(),new ArrayList<>()));
                result.add(temp);
            }
        return result;
    }
```

以及增加了一段判断，本来是在查父字典下所有子类的，但后面前端展示效果不好，就改为如果没有子类(叶结点)就展示他自身

```java
if(totalList == null || totalList.size()<1){
            LambdaQueryWrapper<SysDict> lambdaQueryWrapper = new LambdaQueryWrapper<>();
            lambdaQueryWrapper
                    .eq(SysDict::getDictId,sysDictPageParam.getDictParentId());

            limitList.add(BeanUtil.copyProperties(this.baseMapper.selectOne(lambdaQueryWrapper),SysDictVo.class));
        }
```

### 21.10.18

修复了有关于分页的部分逻辑，采用mybatis-plus的分页。

```java
@Configuration
@ConditionalOnClass(value = {PaginationInterceptor.class})
public class MybatisPlusConfig {

    @Bean
    public PaginationInterceptor mybatisPlusInterceptor() {
        PaginationInterceptor interceptor = new PaginationInterceptor();
        //interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));
        return interceptor;
    }
}
```

修复了无子字典数据时显示父字典本身的显示条数问题

```java
// 在逻辑上新增了这一句 
dictVoIPage.setTotal(temp.size());
```

### 21.11.04

给文章模块新增了几个接口和方法用于渲染数据